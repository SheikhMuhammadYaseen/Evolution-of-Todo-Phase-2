<!--
Sync Impact Report:
Version Change: 1.0.0 → 1.1.0
Amendment Date: 2025-12-27
Amendment Type: MINOR - Material clarification and expansion of phase definitions

Summary:
Corrected phase boundaries and technology timing to align with official Hackathon II requirements.
Phase II now properly defined as full-stack web application (Next.js + FastAPI + SQLModel + Neon DB + Better Auth).

Modified Principles:
- V. Phase Boundary Enforcement → Corrected Phase II description from "REST API only" to "Full-Stack Web Application"
- V. Phase Boundary Enforcement → Corrected Phase III description (no longer introduces Next.js, focuses on advanced features)
- V. Phase Boundary Enforcement → Corrected Phase IV description (no longer introduces database, focuses on scaling)
- VI. Technology Stack Standards → Moved Next.js to "Phase II onward" (was Phase III)
- VI. Technology Stack Standards → Moved SQLModel to "Phase II onward" (was Phase IV)
- VI. Technology Stack Standards → Moved Neon DB to "Phase II onward" (was Phase IV)
- VII. Cloud-Native Architecture Principles → Changed persistent state externalization to "Phase II onward" (was Phase IV)

Rationale:
Official Hackathon II document specifies Phase II as "Full-Stack Web Application" worth 150 points, requiring:
- Next.js responsive frontend with Better Auth and JWT
- FastAPI backend with SQLModel ORM
- Neon DB (PostgreSQL) for persistence
- Multi-user authentication and authorization

Without this correction, Claude Code would incorrectly block Phase II deliverables.

Templates Requiring Updates:
✅ plan-template.md - Constitution Check remains valid (phase boundaries clarified, not fundamentally changed)
✅ spec-template.md - No changes required (requirements structure unaffected)
✅ tasks-template.md - No changes required (task organization unaffected)

Follow-up TODOs: None
-->

# Evolution of Todo Project Constitution

**Project**: Evolution of Todo (Phase I through Phase V)
**Scope**: Multi-phase todo application evolving from CLI to distributed cloud-native system
**Governance Model**: Spec-Driven Development with AI Agent Execution

## Core Principles

### I. Spec-Driven Development Mandate

**All development work MUST follow the Spec-Driven Development (SDD) methodology. No exceptions.**

- Every feature, enhancement, or modification MUST originate from a validated specification document
- Code generation is permitted ONLY after specification approval
- Implementation without approved specification is strictly prohibited
- All code is generated and managed by AI agents; human coding is not permitted

**Rationale**: SDD ensures alignment between business intent and technical output, reduces rework, maintains traceability, and enables consistent quality across all phases. Agent-driven execution eliminates human coding variance and enforces specification compliance.

### II. No Manual Coding

**Human developers are prohibited from writing code directly. All code MUST be generated by AI agents.**

- Humans define requirements, specifications, and approve plans
- AI agents (Claude Code) generate all implementation code
- Manual code edits violate the development model
- Any code corrections MUST be addressed by updating specifications and regenerating

**Rationale**: Agent-driven development ensures consistency with specifications, eliminates subjective coding decisions, and maintains a traceable path from requirement to implementation.

### III. Mandatory Development Sequence

**Every feature MUST progress through the following sequence without skipping steps:**

1. **Constitution** → Project-level principles and constraints (this document)
2. **Specification** → Feature requirements, user stories, acceptance criteria (`/sp.specify`)
3. **Clarify** → Resolution of ambiguities and underspecified areas (`/sp.clarify`)
4. **Plan** → Technical architecture and implementation design (`/sp.plan`)
5. **Tasks** → Decomposed, dependency-ordered work items (`/sp.tasks`)
6. **Implement** → Agent-driven code generation (`/sp.implement`)

Each stage MUST be completed and approved before advancing to the next. Backward iteration to earlier stages is permitted when new information emerges.

**Rationale**: This sequence ensures technical decisions are informed by validated business requirements, prevents scope creep, and maintains architectural coherence.

### IV. Specification Iteration Only

**Code defects or improvement requests MUST be resolved by refining specifications, never by manual code fixes.**

- If Claude Code output is incorrect, update the specification to clarify requirements
- If implementation deviates from intent, refine acceptance criteria and regenerate
- Direct code patches bypass the governance model and are forbidden
- All changes flow through: specification update → plan review → task regeneration → re-implementation

**Rationale**: Maintaining specification as the single source of truth prevents drift between documentation and code, ensures all stakeholders understand changes, and preserves audit trails.

### V. Phase Boundary Enforcement

**Each project phase has a defined scope. Features from future phases MUST NOT appear in earlier phases.**

- **Phase I**: In-memory CLI application. Pure console interface with menu-driven interaction. No persistence, no web, no API, no database, no authentication. Python standard library only.

- **Phase II**: Full-Stack Web Application. Next.js responsive frontend with Better Auth and JWT authentication. FastAPI backend with SQLModel ORM. Neon DB (PostgreSQL) for multi-user persistent storage. RESTful API contracts. No distributed systems, no orchestration, no agent frameworks yet.

- **Phase III**: Advanced web features and optimizations. Enhanced UI/UX, real-time updates, advanced state management, performance optimization, comprehensive error handling. Builds on Phase II full-stack foundation. No distributed architecture yet.

- **Phase IV**: Horizontal scaling and cloud readiness. Load balancing, caching strategies, database replication, container optimization, production monitoring and observability. Prepares for distributed deployment. No orchestration or event streaming yet.

- **Phase V**: Distributed cloud-native architecture. Kubernetes orchestration, Kafka event streaming, Dapr service mesh, microservices decomposition, OpenAI Agents SDK integration, MCP tool integration for agentic behaviors.

Cross-phase dependencies are architectural violations. If a feature requires capabilities from a future phase, defer it or redesign to fit current phase constraints.

Architectural changes that blur phase boundaries MUST be formally proposed via updated specifications and approved plans. Ad-hoc scope expansion is prohibited.

**Rationale**: Phase isolation controls complexity, enables incremental delivery, facilitates testing at each stage, and prevents premature optimization. Each phase delivers a complete, deployable increment with measurable business value.

### VI. Technology Stack Standards

**The following technology standards MUST be adhered to across all phases:**

**Backend**:
- Language: Python (version specified per-phase in technical context)
- API Framework: FastAPI (Phase II onward)
- ORM: SQLModel (Phase II onward)
- Database: Neon DB (PostgreSQL-compatible, Phase II onward)
- Authentication: Better Auth with JWT (Phase II onward)
- Agent Framework: OpenAI Agents SDK (Phase V onward, when agentic behavior required)
- Integration: Official Model Context Protocol (MCP) SDK for tool integration (Phase V onward)

**Frontend** (Phase II onward):
- Framework: Next.js (React-based)
- Language: TypeScript preferred for type safety
- Authentication: Better Auth integration with JWT tokens
- Styling: Responsive design with mobile-first approach

**Infrastructure** (Phase V onward):
- Containerization: Docker
- Orchestration: Kubernetes
- Event Streaming: Kafka
- Service Mesh: Dapr (distributed application runtime)

**Prohibited**:
- Alternative backend languages (e.g., Node.js, Go, Java)
- Non-standard ORMs or data access patterns not approved in plan
- Frontend frameworks other than Next.js (e.g., Vue, Angular, Svelte)
- Infrastructure tools not listed above without architectural approval
- Authentication systems other than Better Auth (Phase II+) without ADR approval

**Substitution Process**: Technology substitutions require ADR (Architecture Decision Record) with justification, tradeoff analysis, and approval before specification.

**Rationale**: Standardization reduces cognitive load, ensures team competency alignment, simplifies tooling and deployment, and prevents fragmentation across phases.

### VII. Cloud-Native Architecture Principles

**All design and implementation MUST adhere to cloud-native best practices:**

**Modularity**:
- Components MUST be independently deployable and testable
- Clear separation of concerns between layers (presentation, business logic, data access)
- Each module exposes well-defined interfaces/contracts

**Statelessness**:
- Services MUST NOT rely on in-memory session state (Phase II onward)
- User context MUST be passed explicitly (tokens, headers, parameters) (Phase II onward)
- Persistent state MUST be externalized to databases or caches (Phase II onward)

**Separation of Concerns**:
- Business logic isolated from infrastructure concerns
- Data models decoupled from transport/API representations
- Cross-cutting concerns (logging, monitoring, auth) handled via middleware or sidecars

**Cloud Readiness**:
- Applications MUST be container-friendly (Phase V onward)
- Configuration via environment variables or external config services
- Horizontal scalability considered in design (no single points of contention)
- Observability built-in: structured logging, metrics, health checks

**Rationale**: Cloud-native principles ensure the application scales efficiently, survives failures gracefully, and integrates seamlessly with modern deployment platforms in later phases.

## Agent Operational Rules

### Agent Constraints

**AI agents (Claude Code) MUST operate under the following constraints:**

- **No Unsolicited Features**: Agents MUST implement only what is specified. Creative additions or "improvements" not in the spec are violations.
- **Strict Specification Adherence**: If the specification is ambiguous, agents MUST request clarification via `/sp.clarify` rather than making assumptions.
- **No Speculative Coding**: Code generation begins only after task approval. Exploratory coding or prototyping outside the task list is prohibited.
- **Phase Awareness**: Agents MUST validate that all dependencies and technologies used belong to the current phase. Use of future-phase features triggers a violation alert.

### Human-Agent Collaboration Model

**Humans and agents have distinct, non-overlapping responsibilities:**

**Human Responsibilities**:
- Define business requirements and user scenarios
- Approve specifications, plans, and task lists
- Make architectural decisions when multiple valid options exist
- Review generated code for correctness against specifications
- Approve phase transitions and scope changes

**Agent Responsibilities**:
- Generate specifications from natural language requirements (`/sp.specify`)
- Perform codebase research and technical analysis
- Design implementation plans aligned with constitution and tech stack
- Decompose plans into executable tasks
- Generate code that satisfies approved tasks
- Create documentation, ADRs, and PHRs automatically

**Collaboration Protocol**:
- Agents MUST invoke humans for clarification when requirements are ambiguous (treat human as a specialized tool)
- Agents MUST present architectural options with tradeoffs when multiple valid approaches exist
- Agents MUST NOT make significant technical decisions without human approval
- Humans MUST NOT bypass agents by writing code directly

**Rationale**: Clear role separation leverages AI strengths (consistency, specification adherence) and human strengths (judgment, context, business priorities).

## Quality Standards

### Code Quality

- **Readability**: Code MUST be self-documenting with clear variable/function names
- **Modularity**: Functions/classes MUST have single, well-defined responsibilities
- **Error Handling**: All external inputs and API calls MUST handle failure cases explicitly
- **Logging**: Structured logging required for all business operations and errors

### Testing Discipline

- **Test-First Optional**: TDD (Test-Driven Development) is encouraged but not mandatory unless explicitly specified in feature requirements
- **Acceptance Testing**: Every user story MUST have acceptance scenarios that can be independently validated
- **Integration Testing**: Cross-component interactions MUST be tested when specified
- **Contract Testing**: API contracts MUST be validated when services communicate (Phase II onward)

### Performance Standards

- **Response Time**: API endpoints MUST respond within defined SLOs (specified per-feature in technical context)
- **Resource Limits**: Applications MUST operate within memory and CPU budgets defined in plan.md
- **Scalability**: Architecture MUST support horizontal scaling from Phase IV onward

### Security Requirements

- **No Hardcoded Secrets**: Credentials, tokens, and keys MUST be externalized to environment variables or secret managers
- **Input Validation**: All user inputs MUST be validated and sanitized
- **Authentication/Authorization**: Security controls MUST be implemented as specified (Phase II onward)
- **Audit Logging**: Security-relevant events MUST be logged with user context

## Development Workflow

### Specification Creation (`/sp.specify`)

1. User provides natural language feature description
2. Agent generates structured specification with:
   - Prioritized user stories (P1, P2, P3...)
   - Functional requirements (FR-001, FR-002...)
   - Acceptance scenarios (Given/When/Then format)
   - Success criteria (measurable outcomes)
3. Human reviews and approves or requests clarifications
4. Agent creates PHR (Prompt History Record) documenting the interaction

### Clarification (`/sp.clarify`)

1. Agent analyzes specification for ambiguities or underspecified areas
2. Agent asks up to 5 targeted clarifying questions
3. Human provides answers
4. Agent encodes answers back into specification
5. Specification version incremented
6. PHR created

### Planning (`/sp.plan`)

1. Agent reads approved specification
2. Agent performs codebase research (if extending existing code)
3. Agent generates implementation plan with:
   - Technical context (languages, frameworks, dependencies)
   - Constitution compliance check
   - Project structure (directories, modules)
   - Data models (if applicable)
   - API contracts (if applicable)
   - Architectural decisions with rationale
4. Human reviews plan and approves or requests revisions
5. If architecturally significant decisions detected, agent suggests ADR creation via `/sp.adr`
6. PHR created

### Task Decomposition (`/sp.tasks`)

1. Agent reads approved specification and plan
2. Agent generates dependency-ordered task list:
   - Grouped by user story (US1, US2, US3...)
   - Marked for parallel execution where possible ([P])
   - Each task specifies exact file paths
   - Tasks include acceptance checks
3. Human approves task list
4. PHR created

### Implementation (`/sp.implement`)

1. Agent executes tasks in dependency order
2. Agent generates code adhering to:
   - Approved specification requirements
   - Plan architecture and structure
   - Constitution principles and tech stack
   - Current phase boundaries
3. Agent runs tests (if specified in tasks)
4. Agent commits work per task or logical grouping via `/sp.git.commit_pr`
5. PHR created for significant implementation decisions

### Architectural Decision Records (`/sp.adr`)

**When to Create ADRs**:
- After planning or task generation, agent applies three-part test:
  1. **Impact**: Does this decision have long-term consequences? (framework, data model, API, security, platform)
  2. **Alternatives**: Were multiple viable options considered?
  3. **Scope**: Is it cross-cutting and influential to system design?
- If ALL true, agent suggests ADR creation (never auto-creates)
- Human consents and provides decision title

**ADR Content**:
- Context: Problem or requirement driving the decision
- Decision: What was chosen
- Options Considered: Alternatives evaluated
- Rationale: Why this option was selected (tradeoffs, constraints, principles)
- Consequences: Positive and negative implications
- Status: Proposed → Accepted → Superseded

### Prompt History Records (PHRs)

**Every user interaction MUST generate a PHR after completion.**

**PHR Routing** (all under `history/prompts/`):
- Constitution stage → `history/prompts/constitution/`
- Feature-specific stages (spec, plan, tasks, implement, etc.) → `history/prompts/<feature-name>/`
- General/misc → `history/prompts/general/`

**PHR Content**:
- User prompt (verbatim, full text)
- Agent response (concise summary)
- Stage (constitution, spec, plan, tasks, etc.)
- Files created/modified
- Tests run/added
- Links to related artifacts (spec, ADR, PR)

**Rationale**: PHRs provide audit trail, enable learning from interactions, and support traceability from requirement to implementation.

## Governance

### Amendment Process

- This constitution supersedes all other practices and guidelines
- Amendments require:
  1. Documented rationale for change
  2. Impact analysis on existing phases and features
  3. Migration plan if existing code/specs affected
  4. Approval by project stakeholders
- Constitution version incremented according to semantic versioning:
  - **MAJOR**: Backward-incompatible governance changes (e.g., removing a core principle)
  - **MINOR**: New principle added or existing principle materially expanded
  - **PATCH**: Clarifications, wording fixes, non-semantic refinements

### Compliance Verification

- All PRs MUST verify constitution compliance before merge
- Plan phase includes mandatory "Constitution Check" gate
- Violations MUST be documented and justified in Complexity Tracking table (plan.md)
- Unjustified violations block implementation

### Conflict Resolution

- When specifications conflict with constitution, constitution wins
- When code conflicts with specification, specification wins (regenerate code)
- When agent output conflicts with approved plan, plan wins (refine agent prompt or specification)

### Integration with Agentic Dev Stack

**This constitution operates as part of a three-component governance system:**

1. **AGENTS.md**: Shared governance defining roles, protocols, and inter-agent communication standards
2. **Spec-Kit Plus (MCP Server)**: Artifact management system handling specifications, plans, tasks, ADRs, and PHRs via Model Context Protocol
3. **Claude Code**: Execution agent that implements this constitution's mandates

**Cross-Reference Protocol**:
- Use `@specs/[path]/file.md` when referencing specifications in Claude Code
- AGENTS.md provides agent-specific instructions; this constitution provides project-specific principles
- Spec-Kit Plus enforces artifact structure; this constitution enforces content and process

**Rationale**: Distributed governance enables reusable agent protocols (AGENTS.md) while maintaining project-specific control (this constitution).

---

**Version**: 1.1.0 | **Ratified**: 2025-12-27 | **Last Amended**: 2025-12-27
